# Cookie / Session / Token

쿠키와 세션을 사용하는 이유

- HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다.
- HTTP 프로토콜 환경에서 서버는 클라이언트가 누구인지 확인해야 한다. 그 이유는 HTTP 프로토콜이 Connectionless, Stateless한 특성이 있기 때문이다.

<br/>
<br/>

## Cookie

---

### Cookie의 의미

쿠키는 주로 웹 서버에 의해 만들어진다. 서버가 HTTP 응답 헤더(header)의 `Set-Cookie`에 내용을 넣어 전달하면, **브라우저는 이 내용을 자체적으로 브라우저에 저장**한다. 이게 바로 쿠키다. 브라우저는 사용자가 쿠키를 생성하도록 한 동일 서버(사이트)에 접속할 때마다 쿠키의 내용을 `Cookie`요청 헤더에 넣어서 함께 전달한다.

<br/>

### Cookie의 동작방식

1. 클라이언트에서 사용자 인증을 위해 서버에 요청한다.
2. 서버는 클라이언트 구분을 위한 session id 와 인증 정보를 DB 와 같은 저장소에 저장한다.
3. 일반적으로 response 에 set-cookie 에 session id 과 함께 클라이언트에 내려주게 된다.
4. 클라이언트에서는 쿠키에 session id 를 함께 저장하게 된다.
5. 필요한 요청마다 session id 와 함께 서버에 요청하게 된다.
6. 서버는 session id 를 통해 저장소에 접근하여 이를 기반으로 인증을 확인한 후, 결과를 내려준다.

쿠키 기반은 stateful 이다. 클라이언트와 서버 둘다 인증 정보를 모두 유지하고 있는 상태를 전제하에 진행된다. 그리고 쿠키는 기본적으로 도메인을 기반으로 설계가 되어있기에 서로 다른 도메인에서 사용할 수 없다.

<br/>

### Cookie의 특징

- 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 데이터 파일이다.
- 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다.
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.
- 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있고, 하나의 쿠키값은 4KB까지 저장한다.
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송한다.

<br/>

### Cookie의 구성

- 이름: 각각의 쿠키를 구별하는 데 사용되는 이름
- 값: 쿠키 이름과 관련된 값
- 유효시간: 쿠키의 유지 시간
- 도메인: 쿠키를 전송할 도메인
- 경로: 쿠키를 전송할 요청경로

<br/>

### Cookie를 통한 로그인 상태 유지

- 로그인에 성공하면 특정 이름을 갖는 쿠키를 생성한다.
- 해당 쿠키가 존재하면 로그인한 상태라고 판단한다.
- 로그아웃하면 해당 쿠키를 삭제한다.

<br/>

### Cookie의 종류

**1. 퍼스트 파티 쿠키(First-Party-Cookie)**

**-** 사용자(client)가 방문한 웹사이트에서 직접 발행하는 쿠키 파일을 말한다. (서브 도메인 포함)

**2. 서드 파티 쿠키(Third-Party-Cookie)**

- 사용자(client)가 방문한 웹사이트가 아닌, 다른 웹사이트에서 발행한 쿠키 파일을 말한다.

<br/>

### CSRF (Cross-Site Request Forgery)

사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 요청하게 하도록 유도하는 것을 말한다.

1. 사용자는 보안이 취약한 서버에 로그인합니다.
2. 로그인 이후 서버에 저장된 세션 정보를 사용할 수 있는 `sessionID`가 사용자 브라우저 쿠키에 저장됩니다.
3. 공격자는 서버에 인증된 브라우저의 사용자가 악성 스크립트 페이지를 누르도록 유도합니다.
    - 해당 악성 스크립트가 담긴 페이지를 클릭하도록 유도하는 방법은 다양한 것 같으나 몇 가지 유형을 정리하자면 다음과 같습니다.
    - 게시판에 악성 스크립트를 게시글로 작성하여 관리자 혹은 다른 사용자들이 게시글을 클릭하도록 유도합니다.
    - 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달합니다.
4. 사용자가 악성 스크립트가 작성된 페이지 접근시 쿠키에 저장된 `sessionID`는 브라우저에 의해 자동적으로 함께 서버로 요청됩니다.
5. 서버는 쿠키에 담긴 `sessionID`를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.

<br/>

### SameSite

`SameSite`는 웹 애플리케이션에서 CSRF(교차 사이트 요청 위조) 공격을 방지하기 위해 HTTP 쿠키에서 설정할 수 있는 속성이다.

- `SameSite`가 **Lax**설정된 경우 쿠키는 동일한 사이트 내의 요청 및 다른 사이트의 GET 요청으로 전송됩니다. 도메인 간 GET 요청으로는 전송되지 않는다.
- **Strict** 값은 쿠키가 동일한 사이트 내의 요청으로만 전송되도록 한다.

Strict는 같은 사이트에서만 쿠키 전송, Lax는 허용한 사이트와 같은 사이트에서만, None은 모든 사이트에서를 의미한다. 기본적으로 `SameSite` 값은 브라우저에서 설정되지 않는다. 이때문에 요청으로 전송되는 쿠키에 대한 제한이 없다. 애플리케이션은 요구사항에 따라 **Lax** 또는 **Strict**를 설정하여 CSRF 보호를 설정해야 한다.

<br/>

### **HTTP Only Cookies**

```java
Set-Cookie: 쿠키명=쿠키값; path=/; HttpOnly
```

document.cookie와 같은 자바스크립트로 쿠키를 조회하는 것을 막는 옵션이다. 브라우저에서 HTTP Only가 설정된 쿠키를 조회할 수 없다. 서버로 HTTP Request 요청을 보낼때만 쿠키를 전송한다.

<br/>

### **Secure Cookies**

Secure는 웹브라우저와 웹서버가 https로 통신하는 경우만 웹브라우저가 쿠키를 서버로 전송하는 옵션이다.


<br/>
<br/>

## Session

---

### Session 동작 방식

1. 클라이언트가 사용자 인증에 성공했을시 세션 ID를 생성한다.
2. 서버는 쿠키에 생성한 세션ID를 담아 클라이언트에 전송한다. (회원정보는 쿠키에 담지 않는다.)
3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용한다.
4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져온다.
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답한다.

<br/>

### Session의 특징

- 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리한다.
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.
- 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능하다.
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다.
- 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다.
- 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션ID다.

<br/>

### Session을 통한 로그인 상태 유지

- 로그인에 성공하면 session 기본객체에 특정 속성에 데이터를 기록한다.
- 이후로 session 기본 객체에 특정 속성이 존재하면 로그인한 것으로 간주한다.
- 로그아웃할 경우 session.invalidate() 메소드를 호출하여 세션을 종료한다.

<br/>

### Cookie - Session 비교

|  | Cookie | Session |
| --- | --- | --- |
| 저장 위치 | 클라이언트 | 서버 |
| 저장 형식 | text | Object |
| 만료 시점 | 쿠키 저장시 설정 (브라우저 종료와 무관) | 브라우저 종료시 삭제 |
| 사용하는 리소스 | 클라이언트 리소스 | 웹 서버 리소스 |
| 용량 제한 | 총 300개 하나의 도메인당 20개 하나의 쿠키당 4KB | 서버가 허용하는 한 용량 제한 없음 |
| 속도 | 세션보다 빠름 | 쿠키보다 느림 |
| 보안 | 세션보다 안좋음 | 쿠키보다 좋음 |

- 가장 큰 차이점은 사용자의 정보가 저장되는 위치이다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용한다.
- 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠르다. 그 이유는 세션은 서버의 처리가 필요하기 때문이다.
- 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 session Id 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋다.
- 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
- 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

<br/>

### **쿠키/세션은 캐시와 다르다**

- 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것이다.
- 한번 캐시에 저장되면 브라우저를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있다.
- 보통 쿠키와 세션의 차이를 물어볼 때 저장위치와 보안에 대해서는 잘 말하는데 사실 중요한 것은 라이프사이클을 얘기하는 것이다.

<br/>
<br/>

## Token

---

### Token의 의미

세션 방식은 안전하고 효과적이지만 단점도 있다. 서버는 요청마다 함께 딸려 오는 세션 아이디를 바로바로 확인할 수 있도록 로그인한 사용자의 아이디를 메모리에 올려둔다. 메모리에 올려둔 데이터를 빠르게 확인할 수 있다는 장점이 있는 대신 공간이 한정되어 있다는 제한사항이 있다. 서버에 동시 접속하는 사용자가 많아지면 메모리 공간이 부족해져서 서버에 부하가 걸리고 화면이 움직이지 않는 등의 문제가 발생할 수 있다. 메모리 공간을 많이 차지하는 세션 방식의 대안은 로그인한 사용자에게 세션 아이디 대신 **토큰**을 발급해 주는 것다. 이러한 토큰에는 특수한 수학적 원리가 적용되어 있어서 마치 위조 방지 장치가 있는 지폐처럼 서버만이 유효한 토큰을 발행할 수 있다. 그렇기 때문에 토큰을 받아간 사용자가 이를 쿠키로 저장해 두고 필요할 때마다 제시하면 서버는 따로 메모리에 올려놓은 것을 확인할 필요 없이 자기가 발급한 토큰임을 알아보고 사용자의 요청을 허가해 주는 것이다. 더 이상 이미 로그인한 사용자의 티켓을 메모리에 올려 두고 있을 필요가 없으니 서버 부하를 줄일 수 있는 것이다.

<br/>

### Token 동작 방식

1. 클라이언트에서 사용자 인증을 위해 서버에 요청한다.
2. 서버는 토큰을 발급하여 클라이언트에 내려준다.
3. 클라이언트는 토큰을 localStorage, sessionStorage, Cookie 와 같은 장소에 저장한다.
4. 필요한 요청마다, 토큰과 함께 서버에 요청한다.서버는 토큰 검사를 통해 인증을 확인하고, 결과를 내려준다.

토큰 기반은 stateless 이다. 서버는 토큰을 발급만 하고, 클라이언트에서 저장된다. 만약 사용자가 로그아웃한다면, 클라이언트에 저장된 토큰만 소멸될 뿐, 서버와의 상호작용은 일어나지 않는다. 그리고 쿠키와 달리 도메인의 영향을 받지 않는다.

<br/>
<br/>

## Reference

[참고: Tistory 쿠키(Cookie), 세션(Session), 캐시(Cache) 정리](https://kihyeoksong.tistory.com/99)

[참고: 혼공 쿠키, 세션, 토큰, 캐시 정리](https://hongong.hanbit.co.kr/%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%ED%86%A0%ED%81%B0-%EC%BA%90%EC%8B%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-cdn/)

[참고: javascript.info: 쿠키와 document.cookie](https://ko.javascript.info/cookie)

[https://docs.microsoft.com/ko-kr/azure/active-directory/develop/howto-handle-samesite-cookie-changes-chrome-browser?tabs=dotnet](https://docs.microsoft.com/ko-kr/azure/active-directory/develop/howto-handle-samesite-cookie-changes-chrome-browser?tabs=dotnet)

[https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)

[https://tmdrl5779.tistory.com/261](https://tmdrl5779.tistory.com/261)

[https://dev.to/ragrag/rest-api-maturity-towards-the-glory-of-rest-5cm3](https://dev.to/ragrag/rest-api-maturity-towards-the-glory-of-rest-5cm3)

[https://junhyunny.github.io/information/security/spring-boot/spring-security/cross-site-reqeust-forgery/](https://junhyunny.github.io/information/security/spring-boot/spring-security/cross-site-reqeust-forgery/)

[https://theheydaze.tistory.com/550](https://theheydaze.tistory.com/550)